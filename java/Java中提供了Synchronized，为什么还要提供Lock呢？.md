# Java中提供了Synchronized，为什么还要提供Lock呢？

## 死锁问题

* 死锁发生的四个必要条件：互斥条件、不可剥夺条件、请求与保持条件、循环等待条件。
* 互斥条件：在一段时间内某资源仅为一个线程占有。此时若有其他线程请求该资源，则请求资源只能等待。
* 不可剥夺条件：线程获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放（只能是主动释放）。
* 请求与保持条件：线程已经保持了一个资源，但又提出了新的资源请求，而改资源已被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不放。
* 循环等待条件：在发生死锁时，形成的一条线程首尾相连的环路，环路中的每一个线程所占有的资源同时被另一个申请。

## Synchronized的局限性

* Synchronized关键字发生了死锁时，是无法破坏“不可剥夺条件”这个死锁的条件的。
* Synchronized申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。

## 如何设计锁

* 能够响应中断。 synchronized的问题是， 持有锁A后， 如果尝试获取锁B失败， 那么线程就进入阻塞状态， 一旦发生死锁，就没有任何机会来唤醒阻塞的线程。 但如果阻塞状态的线程能够响应中断信号， 也就是说当我们给阻塞的线程发送中断信号的时候， 能够唤醒它， 那它就有机会释放曾经持有的锁A。 这样就破坏了不可剥夺条件了。
* 支持超时。 如果线程在一段时间之内没有获取到锁， 不是进入阻塞状态， 而是返回一个错误， 那这个线程也有机会释放曾经持有的锁。 这样也能破坏不可剥夺条件。
* 非阻塞地获取锁。 如果尝试获取锁失败， 并不进入阻塞状态， 而是直接返回， 那这个线程也有机会释放曾经持有的锁。 这样也能破坏不可剥夺条件。

## Lock接口提供的三个方法

* lockInterruptibly()
  * 支持中断
* tryLock()
  * 表示用来尝试获取锁，获取成功，返回true，获取失败，返回false。无论如何都会立即返回，不会在拿不到锁的时一直在那等待。
* tryLock(long time, TimeUnit unit)
  * 和tryLock类似，区别在于这个方法在拿不到锁时会等待一定时间，在时间期限内还拿不到锁，就返回false。
* **对于死锁问题，Lock能够破坏不可剥夺的条件。**

* Lock中还有个ReentrantLock，支持公平锁和非公平锁。

