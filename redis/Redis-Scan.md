## Redis-Scan

* 如何从Redis实例成千上万的key中找出特定前缀的key列表
* `keys`用来列出所有满足特定正则字符串规则的key

```
hp笔记本:0>keys *
 1)  "w"
 2)  "company"
hp笔记本:0>keys c*
 1)  "company"
hp笔记本:0>keys c*y
 1)  "company"
```

* `keys`的缺点
  * 没有 offset、limit 参数，一次性吐出所有满足条件的 key
  * keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令 就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才 可以继续

### Redis指令-scan

* 复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程
* 提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的 结果可多可少
* 同 keys 一样，它也提供模式匹配功能
* 服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数
* 返回的结果可能会有重复，需要客户端去重复，这点非常重要
* 遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
* 单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零

### scan基础使用

* scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三 个是遍历的 limit hint。

```
hp笔记本:0>scan 0 match c* count 2
 1)  "1"
 2)    1)   "company"

hp笔记本:0>scan 1 match c* count 2
 1)  "3"
 2)    1)   "c123"
  2)   "cujd"

hp笔记本:0>scan 3 match c* count 2
 1)  "0"
 2)    1)   "c12"
```

### 字典的结构

* 在 Redis 中所有的 key 都存储在一个很大的字典中，这个字典的结构和 Java 中的 HashMap 一样，是一维数组 + 二维链表结构，第一维数组的大小总是 2^n(n>=0)，扩容一 次数组大小空间加倍，也就是 n++
* scan 指令返回的游标就是第一维数组的位置索引，我们将这个位置索引称为槽 (slot)。 如果不考虑字典的扩容缩容，直接按数组下标挨个遍历就行了。limit 参数就表示需要遍历的 槽位数，之所以返回的结果可能多可能少，是因为不是所有的槽位上都会挂接链表，有些槽 位可能是空的，还有些槽位上挂接的链表上的元素可能会有多个。每一次遍历都会将 limit  数量的槽位上挂接的所有链表元素进行模式匹配过滤后，一次性返回给客户端
* scan 指令是一系列指令，除了可以遍历所有的 key 之外，还可以对指定的容器集合进 行遍历。比如 zscan 遍历 zset 集合元素，hscan 遍历 hash 字典的元素、sscan 遍历 set 集 合的元素

